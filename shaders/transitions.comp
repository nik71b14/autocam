// You dispatch your compute with local_size_x = 1, local_size_y = 1.
// Each invocation corresponds to a single row y (the scanline).
// You do a linear scan along x in the row, detecting red/non-red transitions.
// You write the transition X positions to transitions[].
// transitionCounter is atomically incremented by (resolution + 1) per row to reserve space.
// The first element in the reserved block (transitions[baseIndex]) is set to zero (maybe a count or marker?).
// The rest of the elements store transition X positions.
// At the end, in the last invocation (last row and x==0), you write the sentinel.

#version 460
layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0, rgba8) readonly uniform image2D colorTex;

layout(std430, binding = 1) buffer TransitionBuffer {
    uint transitions[];
};

layout(std430, binding = 2) buffer CounterBuffer {
    uint transitionCounter; // Space allocation counter
    uint totalTransitions;  // Actual transitions count
    uint padding2;
    uint padding3;
};

uniform int resolution;
uniform uint maxTransitionCount;
uniform uint maxTransitionsPerRow; // Added: Max transitions per row (e.g., 32)

bool isRed(vec4 color) {
    return color.r > 0.5 && color.r > color.g + 0.05 && color.r > color.b + 0.05;
}

void main() {
    uint y = gl_GlobalInvocationID.y;
    if (y >= uint(resolution)) return;

    // Reserve space for this row (fixed size per row)
    uint baseIndex = atomicAdd(transitionCounter, maxTransitionsPerRow);
    if (baseIndex + maxTransitionsPerRow > maxTransitionCount) return;

    // Initialize marker and counter
    transitions[baseIndex] = 0u;
    uint count = 1u;

    // Scan the row
    vec4 prev = imageLoad(colorTex, ivec2(0, int(y)));
    bool wasRed = isRed(prev);

    for (uint x = 1u; x < uint(resolution); ++x) {
        vec4 curr = imageLoad(colorTex, ivec2(int(x), int(y)));
        bool isCurrRed = isRed(curr);

        if (isCurrRed != wasRed) {
            // Prevent overflow in reserved block
            if (count >= maxTransitionsPerRow) break;
            
            transitions[baseIndex + count] = x;
            count++;
            wasRed = isCurrRed;
        }
    }

    // Update actual transitions count (excluding initial marker)
    atomicAdd(totalTransitions, count - 1u);

    // Write sentinel once at the end of all processing
    if (gl_GlobalInvocationID.y == resolution - 1 && 
        gl_GlobalInvocationID.x == 0 && 
        gl_GlobalInvocationID.z == 0) {
        transitions[maxTransitionCount - 1] = 0xDEADBEEFu;
    }
}

/*
#version 460
layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0, rgba8) readonly uniform image2D colorTex;

layout(std430, binding = 1) buffer TransitionBuffer {
    uint transitions[];
};

layout(std430, binding = 2) buffer CounterBuffer {
    uint transitionCounter; // Space allocation
    uint totalTransitions;  // Actual transitions count
    uint padding2;
    uint padding3;
};

uniform int resolution;
uniform uint maxTransitionCount;

bool isRed(vec4 color) {
    return color.r > 0.5 && color.r > color.g + 0.05 && color.r > color.b + 0.05;
}

void main() {
    uint y = gl_GlobalInvocationID.y;
    if (y >= uint(resolution)) return;

    // Reserve space for this row (max 'resolution' entries)
    uint baseIndex = atomicAdd(transitionCounter, resolution);
    if (baseIndex + resolution >= maxTransitionCount) return;

    transitions[baseIndex] = 0u; // Initial marker

    vec4 prev = imageLoad(colorTex, ivec2(0, int(y)));
    bool wasRed = isRed(prev);
    uint count = 1u;

    for (uint x = 1u; x < uint(resolution); ++x) {
        vec4 curr = imageLoad(colorTex, ivec2(int(x), int(y)));
        bool isCurrRed = isRed(curr);

        if (isCurrRed != wasRed) {
            transitions[baseIndex + count] = x;
            count++;
            wasRed = isCurrRed;
        }
    }

    // Update actual transitions count (subtract 1 to exclude the initial 0)
    atomicAdd(totalTransitions, count - 1u);

    // Sentinel write
    if (gl_GlobalInvocationID.y == resolution - 1 && gl_GlobalInvocationID.x == 0) {
        transitions[maxTransitionCount - 1] = 0xDEADBEEF;
    }
    // Write sentinel within the buffer
    // if (gl_GlobalInvocationID.y == resolution - 1 && gl_GlobalInvocationID.x == 0) {
    //     transitions[min(maxTransitionCount - 1, baseIndex + count)] = 0xDEADBEEF; // Safer write
    // }
}
*/