#version 460

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// ====================
// Buffer Bindings
// ====================

// Binding 0: Vertex buffer (vec3)
layout(std430, binding = 0) readonly buffer VertexBuffer {
    vec3 vertices[];
};

// Binding 1: Index buffer (uint triplets)
layout(std430, binding = 1) readonly buffer IndexBuffer {
    uint indices[];
};

// Struct for Z-transition event (Z, X, Y, Enter/Exit)
struct Transition {
    float z;
    uint x;
    uint y;
    uint enter; // 1 = enter, 0 = exit
};

// Binding 2: Transition output buffer
layout(std430, binding = 2) buffer TransitionBuffer {
    Transition transitions[];
};

// Binding 3: Atomic counter for writing transitions
layout(std430, binding = 3) buffer CounterBuffer {
    uint transitionCounter;
};

// ====================
// Uniform Inputs
// ====================
uniform int triangleCount;
uniform int gridRes;
uniform vec3 bboxMin;
uniform vec3 bboxMax;

// ====================
// Utility Functions
// ====================

// Transform from world-space to voxel grid space
vec3 toGridSpace(vec3 pos) {
    vec3 relative = (pos - bboxMin) / (bboxMax - bboxMin);
    return clamp(relative * float(gridRes), vec3(0.0), vec3(gridRes - 1));
}

// Compute signed edge function for triangle rasterization
float edgeFunc(vec2 a, vec2 b, vec2 c) {
    return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
}

// Safely append a transition pair (enter and exit) using atomic counter
void insertTransition(uint x, uint y, float z1, float z2) {
    //if (z1 == z2) return; // Skip zero-thickness transitions
    //if (abs(z1 - z2) < 1e-6) return; // Skip almost zero-thickness transitions

    if (z1 == z2) {
        // Artificially stretch to ensure insertion
        z2 += 1e-5;
    }

    // Determine ordering
    float zEnter = min(z1, z2);
    float zExit  = max(z1, z2);

    // Insert 'enter' transition
    uint idx1 = atomicAdd(transitionCounter, 1);
    transitions[idx1] = Transition(zEnter, x, y, 1);

    // Insert 'exit' transition
    uint idx2 = atomicAdd(transitionCounter, 1);
    transitions[idx2] = Transition(zExit, x, y, 0);
}

// ====================
// Main Shader Logic
// ====================

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= uint(triangleCount)) return;

    // Fetch triangle vertex indices
    uint i0 = indices[3 * gid + 0];
    uint i1 = indices[3 * gid + 1];
    uint i2 = indices[3 * gid + 2];

    // Fetch world-space triangle vertices
    vec3 v0 = vertices[i0];
    vec3 v1 = vertices[i1];
    vec3 v2 = vertices[i2];

    // Convert to grid space
    vec3 gv0 = toGridSpace(v0);
    vec3 gv1 = toGridSpace(v1);
    vec3 gv2 = toGridSpace(v2);

    // Extract XY positions for rasterization
    vec2 v0xy = gv0.xy;
    vec2 v1xy = gv1.xy;
    vec2 v2xy = gv2.xy;

    // Compute 2D bounding box in XY
    ivec2 minXY = ivec2(clamp(floor(min(v0xy, min(v1xy, v2xy))), vec2(0), vec2(gridRes - 1)));
    ivec2 maxXY = ivec2(clamp(ceil (max(v0xy, max(v1xy, v2xy))), vec2(0), vec2(gridRes - 1)));

    // Compute signed area of triangle
    float area = edgeFunc(v0xy, v1xy, v2xy);
    if (area == 0.0) return; // Degenerate triangle (line or point)

    // Rasterize covered XY cells
    for (int y = minXY.y; y <= maxXY.y; ++y) {
        for (int x = minXY.x; x <= maxXY.x; ++x) {
            vec2 p = vec2(x + 0.5, y + 0.5); // Pixel center

            float w0 = edgeFunc(v1xy, v2xy, p);
            float w1 = edgeFunc(v2xy, v0xy, p);
            float w2 = edgeFunc(v0xy, v1xy, p);

            // Inside test (CCW triangle)
            if (w0 >= 0.0 && w1 >= 0.0 && w2 >= 0.0) {
                // Normalize barycentric weights
                w0 /= area;
                w1 /= area;
                w2 /= area;

                // Interpolated Z at this XY point
                float interpolatedZ = w0 * gv0.z + w1 * gv1.z + w2 * gv2.z;

                // Conservative vertical extent
                float minZ = min(gv0.z, min(gv1.z, gv2.z));
                float maxZ = max(gv0.z, max(gv1.z, gv2.z));

                // Store transitions (use full min/max extent for conservative fill)
                insertTransition(uint(x), uint(y), minZ, maxZ);
            }
        }
    }
}
