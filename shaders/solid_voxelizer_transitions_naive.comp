void solidVoxelizeTransition(
  const char* stlPath,
  GLuint& transitionsSSBO,
  GLuint& vertexSSBO,
  GLuint& indexSSBO,
  VoxelizerComputeShader* computeShader,
  const glm::vec3& bboxMin,
  const glm::vec3& bboxMax)
{
    std::vector<glm::vec3> vertices;
    std::vector<unsigned int> indices;
    float zSpan = 1.01f * loadMeshVec3(stlPath, vertices, indices);
    std::cout << "zSpan: " << zSpan << std::endl;

    auto [bbMin, bbMax] = computeBoundingBoxVec3(vertices);
    std::cout << "Min scaled coordinates: (" << bbMin.x << ", " << bbMin.y << ", " << bbMin.z << ")\n";
    std::cout << "Max scaled coordinates: (" << bbMax.x << ", " << bbMax.y << ", " << bbMax.z << ")\n";

    const int GRID_RES = 1024;
    const int TRIANGLE_COUNT = indices.size() / 3;
    const int MAX_TRANSITIONS_PER_COLUMN = 32; // tune this

    // Buffer size for transitions: gridRes * gridRes * maxTransitions * uint
    size_t transitionsCount = GRID_RES * GRID_RES * MAX_TRANSITIONS_PER_COLUMN;

    glGenBuffers(1, &transitionsSSBO);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, transitionsSSBO);
    glBufferData(GL_SHADER_STORAGE_BUFFER, transitionsCount * sizeof(uint32_t), nullptr, GL_DYNAMIC_DRAW);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, transitionsSSBO);

    glGenBuffers(1, &vertexSSBO);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, vertexSSBO);
    glBufferData(GL_SHADER_STORAGE_BUFFER, vertices.size() * sizeof(glm::vec3), vertices.data(), GL_STATIC_DRAW);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, vertexSSBO);

    glGenBuffers(1, &indexSSBO);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, indexSSBO);
    glBufferData(GL_SHADER_STORAGE_BUFFER, indices.size() * sizeof(uint32_t), indices.data(), GL_STATIC_DRAW);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, indexSSBO);

    computeShader->use();
    computeShader->setInt("gridRes", GRID_RES);
    computeShader->setInt("triangleCount", TRIANGLE_COUNT);
    computeShader->setInt("maxTransitions", MAX_TRANSITIONS_PER_COLUMN);
    computeShader->setVec3("bboxMin", bboxMin);
    computeShader->setVec3("bboxMax", bboxMax);

    glDispatchCompute((TRIANGLE_COUNT + 63) / 64, 1, 1);
    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
}
